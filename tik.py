#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# tik.py

import os
import logging
import asyncio
from pathlib import Path
from functools import wraps

from telegram import Update, ChatMember, BotCommand
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
)
import yt_dlp
import diskcache
from dotenv import load_dotenv

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù…Ù† Ù…Ù„Ù .env
load_dotenv()

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# CONFIGURATION
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
TOKEN          = os.getenv("TELEGRAM_BOT_TOKEN")
DOWNLOAD_DIR   = Path(os.getenv("DOWNLOAD_DIR", "downloads"))
CACHE_DIR      = Path(os.getenv("CACHE_DIR", "cache"))
MAX_CACHE_SIZE = int(os.getenv("MAX_CACHE_SIZE", "1000000000"))  # 1 GB

# Ø¶Ø¹ Ø§Ø³Ù… Ù‚Ù†Ø§ØªÙƒ Ù‡Ù†Ø§ØŒ Ù…Ø¹ Ø¹Ù„Ø§Ù…Ø© @
CHANNEL_USERNAME = "@redotpaylfiicial"

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# LOGGER
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
logging.basicConfig(
    format="%(asctime)s %(levelname)s %(name)s â–¶ %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# CACHE FOR AVOIDING REDOWNLOADS
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
cache = diskcache.Cache(str(CACHE_DIR), size_limit=MAX_CACHE_SIZE)

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# HELPER DECORATORS
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
def require_channel_membership(channel_username: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
            user_id = update.effective_user.id
            try:
                member = await ctx.bot.get_chat_member(
                    chat_id=channel_username,
                    user_id=user_id
                )
            except Exception:
                return await update.message.reply_text(
                    "âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§ÙƒÙƒØŒ ØªØ£ÙƒÙ‘Ø¯ Ù…Ù† Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª ÙƒÙ…Ø³Ø¤ÙˆÙ„ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©."
                )

            if member.status in (
                ChatMember.MEMBER,
                ChatMember.ADMINISTRATOR,
                ChatMember.OWNER
            ):
                return await func(update, ctx)
            else:
                return await update.message.reply_text(
                    f"âŒ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ {channel_username} Ø£ÙˆÙ„Ø§Ù‹."
                )
        return wrapper
    return decorator

def send_typing(func):
    @wraps(func)
    async def wrapper(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        await ctx.bot.send_chat_action(update.effective_chat.id, "upload_video")
        return await func(update, ctx)
    return wrapper

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# /start COMMAND
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
@require_channel_membership(CHANNEL_USERNAME)
async def start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "ðŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹! Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ (YouTube, TikTok, Instagram...) ÙˆØ³Ø£Ø±Ø³Ù„Ù‡ Ù„Ùƒ Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù…Ø© Ù…Ø§Ø¦ÙŠØ©."
    )

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# DOWNLOAD & CACHE LOGIC
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
async def download_video(url: str) -> Path:
    if url in cache:
        path = Path(cache[url])
        if path.exists():
            logger.info("Cache hit for %s", url)
            return path
        cache.pop(url, None)

    DOWNLOAD_DIR.mkdir(exist_ok=True)
    outtmpl = str(DOWNLOAD_DIR / "%(id)s.%(ext)s")
    ydl_opts = {
        "outtmpl": outtmpl,
        "format": "mp4[height<=720]/mp4",
        "noplaylist": True,
        "quiet": True,
    }
    loop = asyncio.get_event_loop()
    info = await loop.run_in_executor(
        None, lambda: yt_dlp.YoutubeDL(ydl_opts).extract_info(url, download=True)
    )
    path = DOWNLOAD_DIR / f"{info['id']}.{info['ext']}"
    cache.set(url, str(path))
    return path

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# MESSAGE HANDLER
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
@require_channel_membership(CHANNEL_USERNAME)
@send_typing
async def handle_link(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    url = update.message.text.strip()
    chat_id = update.effective_chat.id

    # 1) ØªÙ†Ø²ÙŠÙ„ Ø£Ùˆ Ø¬Ù„Ø¨ Ù…Ù† Ø§Ù„ÙƒØ§Ø´
    try:
        video_path = await download_video(url)
    except Exception:
        logger.exception("Download error")
        return await update.message.reply_text("Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ­Ù…ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ")

    # 2) Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø³ÙŠØ·Ø© Ø¹Ù„Ù‰ Timeout
    try:
        with open(video_path, "rb") as f:
            try:
                await ctx.bot.send_video(chat_id, video=f)
            except Exception as e:
                msg = type(e).__name__.lower()
                if "timeout" in msg or "readtimeout" in msg:
                    logger.warning("Timeout on first send, retryingâ€¦")
                    f.seek(0)
                    await ctx.bot.send_video(chat_id, video=f)
                else:
                    raise
    except Exception:
        logger.exception("Send error")
        await update.message.reply_text("Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§ Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ")

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# MAIN ENTRYPOINT
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
if __name__ == "__main__":
    async def on_startup(app):
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¸Ø§Ù‡Ø±Ø© ÙÙŠ Ø²Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø«Ù„Ø§Ø«ÙŠØ©
        await app.bot.set_my_commands([
            BotCommand("start", "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¨ÙˆØª")
        ])

    app = (
        ApplicationBuilder()
        .token(TOKEN)
        .post_init(on_startup)
        .build()
    )
    # Ø±Ø¨Ø· Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙŠØ© Ø¹Ù„Ù‰ http:// Ø£Ùˆ https:// Ø¨Ø§Ù„Ø¯Ø§Ù„Ø© handle_link
    app.add_handler(
        MessageHandler(
            filters.Regex(r"https?://\S+"),
            handle_link
        )
    )
    app.add_handler(CommandHandler("start", start))
    logger.info("Bot is starting...")
    app.run_polling()
